# Registry-Driven Graph (Step 10)

## Обзор

Реализован **Registry-Driven Graph Engine** — механизм для read-only навигации по графу сущностей.

---

## Архитектура Безопасности

### 1. Secure Core Guard
[GraphGuard](file:///f:/Matrix_Gin/backend/src/graph/graph.guard.ts#13-65) строго валидирует каждый запрос:
*   **Root Check**: `view.root` обязан совпадать с запрашиваемым `entityType`.
*   **Whitelist Logic**: Траверсинг разрешен *только* по ребрам из `view.edges` и в узлы из `view.nodes`.
*   **No Inference**: Если связь есть в БД, но не в View — она **невидима**.

### 2. Data Minimization
API (`GET /api/graph/...`) возвращает только топологию:
```json
{
  "nodes": [{ "id": "...", "entityType": "...", "label": "..." }],
  "edges": [{ "source": "...", "target": "...", "relation": "..." }]
}
```
Атрибуты намеренно исключены. Для деталей — переходите в Entity Card.

---

## Frontend Engine ([RegistryGraph](file:///f:/Matrix_Gin/frontend/src/entity-graph/core/RegistryGraph.tsx#91-188))

Использует `reactflow` + `dagre` для автоматической раскладки.
*   **Layout**: Слева направо (LR).
*   **Interaction**: Клик по узлу -> переход на `/app/entities/:type/:id`.

---

## Проверка Интеграции

Конфигурация `UserAccount` (`backend/.../01_user_account.entity.json`):

```json
"views": {
    "graph.default": {
        "type": "graph",
        "root": "user_account",
        "nodes": ["user_account", "role"],
        "edges": ["roles"],
        "depth": 2
    }
}
```

### Пример использования

```tsx
<RegistryGraph 
    entityType="user_account" 
    entityId="123" 
    viewName="graph.default" 
/>
```

---

## Результат

✅ **Declarative Graphs**: Графы определяются в Registry, а не в коде.
✅ **Secure Traversal**: Нельзя "случайно" показать лишние связи.
✅ **Visual Exploration**: База для Impact Analysis.
